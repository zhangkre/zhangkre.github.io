<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Silhouettes
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Silhouettes</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-java类的生命周期" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/18/java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >java类的生命周期</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/18/java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2020-07-18T10:06:52.000Z" itemprop="datePublished">2020-07-18</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://pic.downk.cc/item/5f12c9b714195aa5947108bb.jpg" alt=""></p>
<hr>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><h2 id="加载的过程"><a href="#加载的过程" class="headerlink" title="加载的过程"></a>加载的过程</h2><p>“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：  </p>
<ul>
<li>通过类的全限定名获取该类的二进制字节流。</li>
<li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li>
<li>在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="获取二进制字节流"><a href="#获取二进制字节流" class="headerlink" title="获取二进制字节流"></a>获取二进制字节流</h3><p>对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式： </p>
<ul>
<li>从 zip 包中读取，如 jar、war等</li>
<li>从网络中获取，如 Applet</li>
<li>通过动态代理技术生成代理类的二进制字节流</li>
<li>由 JSP 文件生成对应的 Class 类</li>
<li>从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<h3 id="非数组类”与“数组类”加载比较"><a href="#非数组类”与“数组类”加载比较" class="headerlink" title="非数组类”与“数组类”加载比较"></a>非数组类”与“数组类”加载比较</h3><ul>
<li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 loadClass() 方法）</li>
<li>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。</li>
<li>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。</li>
</ul>
<hr>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。  </p>
<h2 id="验证的过程"><a href="#验证的过程" class="headerlink" title="验证的过程"></a>验证的过程</h2><ul>
<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：<ul>
<li>是否以魔数 0XCAFEBABE 开头</li>
<li>主次版本号是否在当前虚拟机处理范围内</li>
<li>常量池是否有不被支持的常量类型</li>
<li>指向常量的索引值是否指向了不存在的常量</li>
<li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据</li>
<li>……</li>
</ul>
</li>
<li>元数据验证：对字节码描述信息进行语义分析，确保其符合 Java 语法规范。</li>
<li>字节码验证：本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</li>
<li>符号引用验证：本阶段发生在解析阶段，确保解析正常执行。</li>
</ul>
<hr>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备阶段是正式为<strong>类变量（或称“静态成员变量”）</strong>分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在<strong>方法区</strong>中进行分配。</p>
<p>初始值“通常情况下”是数据类型的零值<code>（0, null...）</code>，假设一个类变量的定义为：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么变量 <code>value</code> 在准备阶段过后的初始值为 <code>0</code>而不是 <code>123</code>，因为这时候尚未开始执行任何 Java 方法。</p>
<p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，即<strong>final</strong>修饰的变量，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么在准备阶段虚拟机会根据<code>ConstantValue</code> 的设置将 <code>value</code> 赋值为 <code>123</code>。</p>
<hr>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一句话，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<hr>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>类初始化阶段是类加载过程的最后一步，是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p>
<p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（<code>static {}</code> 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p>
<p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;  <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;clinit&gt;()</code>方法不需要显式调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。<br>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Sub.B); <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>接口中不能使用静态代码块，但接口也需要通过<code>&lt;clinit&gt;()</code>方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父类的<code>&lt;clinit&gt;()</code> 方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-init和cinit的区别" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/18/init%E5%92%8Ccinit%E7%9A%84%E5%8C%BA%E5%88%AB/"
    >init和clinit的区别</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/18/init%E5%92%8Ccinit%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-07-18T09:57:09.000Z" itemprop="datePublished">2020-07-18</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h4 id="init和clinit的区别"><a href="#init和clinit的区别" class="headerlink" title="init和clinit的区别"></a>init和clinit的区别</h4><ol>
<li>执行的目的不同<ul>
<li>init是对象的构造器方法，对<strong>非静态</strong>变量解析初始化</li>
<li>clinit是class类构造器，对静态变量、静态代码块进行初始化</li>
</ul>
</li>
<li>执行时机不同<ul>
<li>init是在程序执行new一个对象时调用该对象的constructor方法时才会执行init方法</li>
<li>clinit是在jvm进行类<strong>加载–验证–解析–初始化</strong>时的<strong>初始化</strong>阶段会调用clinit方法</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-java常量池" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/18/java%E5%B8%B8%E9%87%8F%E6%B1%A0/"
    >java常量池</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/18/java%E5%B8%B8%E9%87%8F%E6%B1%A0/" class="article-date">
  <time datetime="2020-07-18T09:14:02.000Z" itemprop="datePublished">2020-07-18</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <ul>
<li>常量池<br>class文件中的用来存放编译器生成的各种字面量和符号引用</li>
<li>运行时常量池<br>方法区中的运行常量池。类加载器加载class文件的时候会将上述的class文件中的常量池加载到<strong>运行时常量池</strong></li>
<li>字符串常量池<br>用来存放字符串。字符串常量池在堆中</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-jvm内存分布" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/17/jvm%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"
    >jvm内存分布</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/17/jvm%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" class="article-date">
  <time datetime="2020-07-17T14:11:25.000Z" itemprop="datePublished">2020-07-17</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="1-虚拟机的构成"><a href="#1-虚拟机的构成" class="headerlink" title="1. 虚拟机的构成"></a>1. 虚拟机的构成</h3><p>虚拟机主要由 运行时数据区、 执行引擎、 类加载器 三者构成。<br><img src="https://pic.downk.cc/item/5f11b18914195aa5941ef94a.png" alt="">  </p>
<h5 id="1-1-运行时数据区"><a href="#1-1-运行时数据区" class="headerlink" title="1.1 运行时数据区"></a>1.1 运行时数据区</h5><p><img src="https://pic.downk.cc/item/5f11b28114195aa5941f3f1a.png" alt=""></p>
<ul>
<li>方法区<br><img src="https://pic.downk.cc/item/5f11b30414195aa5941f6a79.png" alt=""></li>
</ul>
<p>方法区存放着class文件的信息，还包括存储class常量的常量池<br>常量池主要用来存放两大类常量：<strong>字面量</strong>和<strong>符号引用量</strong></p>
<hr>
<ul>
<li>字面量<ul>
<li>文本字符串</li>
<li>final常量</li>
</ul>
</li>
<li>符号引用量<ul>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符  </li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>class文件中的常量池中的内容会在类加载后进入方法区的运行时常量池。相对于常量池，运行时常量池的重要特征是具有动态性，java并不要求常量只有在编译器才会产生，运行期间也可以将新的常量存放入池中，这种特性用的最多的String类中的intern()方法。  </li>
<li>对于byte、short、long、char、boolean对应的包装器类都有对应的常量池，这五种包装器类默认创建在<strong>-128到127</strong>的对象会存放在在缓存中。对于<strong>两种浮点数没有</strong>实现常量池技术。</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f11ddf414195aa594307213.png" alt=""></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-可靠传输的实现机制" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/10/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"
    >可靠传输的实现机制</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/10/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-07-09T16:03:00.000Z" itemprop="datePublished">2020-07-10</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h2><ul>
<li>停止等待协议（SW）</li>
<li>后退N帧协议（GBN）</li>
<li>选择重传协议（SR）</li>
</ul>
<hr>
<h3 id="1-停止等待协议（SW）"><a href="#1-停止等待协议（SW）" class="headerlink" title="1. 停止等待协议（SW）"></a>1. 停止等待协议（SW）</h3><p>要点：<br>    - 每发送一个数据就停止发送，等待对方的确认<br>    - 收到确认后再发送下一个数据帧</p>
<p><img src="https://pic.downk.cc/item/5f07420114195aa5949240d5.jpg" alt=""><br><img src="https://pic.downk.cc/item/5f07440014195aa59492dac8.jpg" alt=""></p>
<hr>
<h3 id="2-后退N帧协议（GBN）"><a href="#2-后退N帧协议（GBN）" class="headerlink" title="2. 后退N帧协议（GBN）"></a>2. 后退N帧协议（GBN）</h3><p><em>要点:</em></p>
<ul>
<li><strong>后退N帧协议是基于滑动窗口流量控制技术的。</strong><ul>
<li>发送方的发送窗口尺寸W_T必须满足：1 &lt; W_T &lt; 2^n - 1 其中，n是构成帧序号的比特数量；  <ul>
<li>若 W_T=1: 停止等待协议</li>
<li>若 W_T &gt; 2^n - 1: 造成接收方无法分辨新、旧数据帧的问题</li>
</ul>
</li>
<li>接收方的接收窗口尺寸W_R必须满足： W_R=1 因此，接收方只能按顺序接收数据帧</li>
</ul>
</li>
<li><strong>发送方可在未收到接收方确认帧的情况下，将序号落在发送窗口内的多个数据帧全部发送出去</strong></li>
<li><strong>接收方只接收序号落在接收窗口内且无误码的数据帧，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认帧。为了减小开销，</strong> <ul>
<li><em>接收方不一定每收到一个按序到达且无误码的数据帧就给发送方发回一个确认帧，而是可以在连续收到好几个按序到达且无误码的数据帧后，才针对最后一个数据帧发送确认帧，这称为</em> <strong>累计确认</strong></li>
<li><em>或者可以在自己有数据帧要发送的时候才对之前按序到达且无误码的数据帧进行</em> <strong>捎带确认</strong> </li>
</ul>
</li>
<li><strong>发送方只有在收到对已发送数据帧的确认时，发送窗口才能向前相应滑动</strong></li>
<li><strong>发送方发送窗口内某个已发送的数据帧产生超时重发时，其后续在发送窗口内且已发送的数据帧也必须全部重传，这就是后退N帧协议名称的由来</strong></li>
</ul>
<hr>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-JAVA集合类" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/09/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"
    >JAVA集合类</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/09/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/" class="article-date">
  <time datetime="2020-07-09T15:29:44.000Z" itemprop="datePublished">2020-07-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-数据链路层的三个问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/09/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/"
    >数据链路层的三个问题</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/09/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-07-09T15:02:28.000Z" itemprop="datePublished">2020-07-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><strong>数据链路层三个问题：封装成帧、透明传输、差错检查</strong>  </p>
<hr>
<p><strong>点对点信道的数据链路层在进行通信的时步骤如下：</strong><br><em>1. 节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</em></p>
<p><em>2. 节点A把封装好的帧发送给节点B的数据链路层。</em></p>
<p><em>3. 若节点B的数据链路层收到的帧无差错，则从收到的帧当中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。</em></p>
<hr>
<h2 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h2><p><strong>封装成帧就是在一段数据的前后分别加上帧头和帧尾；</strong><br>    - 帧首部 SOH<br>    - 数据部分<br>      - 帧头 6 + 6 + 2<br>      - 帧尾 4<br>      - 数据 46-1500<br>    - 帧尾部 EOT<br><img src="https://pic.downk.cc/item/5f07337014195aa5948d532b.jpg" alt=""></p>
<hr>
<h2 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h2><p><strong>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</strong><br><img src="https://pic.downk.cc/item/5f07370414195aa5948e84c5.png" alt=""><br><img src="https://pic.downk.cc/item/5f07374714195aa5948e9c9c.png" alt=""></p>
<hr>
<h2 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h2><p><strong>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</strong><br>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-二叉搜索树" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"
    >二叉搜索树</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time datetime="2020-07-03T13:36:00.000Z" itemprop="datePublished">2020-07-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h2><p>二叉搜索树的结构有两种可能：</p>
<ul>
<li>空树</li>
<li>左子节点的值小于根节点，右子节点的值大于根节点  </li>
</ul>
<p>** 基本操作 **</p>
<ol>
<li>查找  </li>
<li>插入</li>
<li>删除</li>
</ol>
<hr>
<ol>
<li>查找  </li>
</ol>
<ul>
<li>遍历二叉树，如果当前遍历的节点为空，则以为着没有目标结点，直接返回</li>
<li>若当前遍历的结点的值正好和目标值相等，则查找成功，返回</li>
<li>若当前遍历的结点的值大于目标值，则应该在该结点的左子树进行查找，设置下一步遍历范围为root.left，继续递归遍历</li>
<li>若当前遍历的结点的值小于目标值，则应该在该结点的右子树进行查找，设置下一步遍历范围为root.right，继续递归遍历</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-高频面试题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/10/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
    >高频面试题</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/10/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-06-10T10:42:13.000Z" itemprop="datePublished">2020-06-10</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <ol>
<li>线程和进程的区别？<br>　　<strong>进程是资源（CPU、内存等）分配的基本单位</strong>，具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>　　<strong>线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）</strong>。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li>
<li>TCP三次握手和四次挥手？</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-JAVA-CLASS文件结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/09/JAVA-CLASS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"
    >JAVA CLASS文件结构</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/09/JAVA-CLASS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-06-08T16:17:44.000Z" itemprop="datePublished">2020-06-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><strong>javac</strong> 全称是 <code>java complier</code><br><strong>javap</strong> 是<code>java</code>反解析工具，可以将<code>class</code>字节码文件，反解析出当前类对应的<code>code</code>区、本地变量表、异常表和代码行偏移量映射表、常量池等信息<br>javap 一般用法：javap -v -c -l<br>-l 会输出行号和本地变量表信息<br>-c 会对当前<code>class</code>字节码进行反编译生成汇编代码<br>-v 不仅会输出行号、本地变量表、反编译汇编码，还会输出当前类用到的常量池等信息  </p>
<p>使用jclasslib可以可视化class结构<br><img src="https://pic.downk.cc/item/5ede665cc2a9a83be54fb6bf.jpg" alt=""><br>使用网上的工具Classpy也能可视化查看class字节码<br><img src="https://pic.downk.cc/item/5ede66bfc2a9a83be5505cc4.jpg" alt=""><br>和这个对应<br><img src="https://pic.downk.cc/item/5ede66ecc2a9a83be550a91f.jpg" alt=""></p>
<p><em>tips:</em>  java -jar xxxx.jar  可在命令行运行jar文件,会阻塞命令行；<br>javaw运行java文件不会阻塞命令行</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Zhang-Ke
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278630748&amp;web_id=1278630748'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Silhouettes"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['我心中尚未崩坏的地方','所以暂时将你眼镜闭了起来',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>